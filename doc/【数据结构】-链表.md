
* 链表的存储结构

链表不需要一块连续的内存空间，它是通过"指针"将一组零散的内存块串联起来使用。

假如现在申请100M的数组，如果没有连续的内存空间，会申请失败，但是申请100M的链表，是可以成功的，说明链表的存储结构不需要连续的内存空间，只要内存满足需求就可以。

* 链表的结构分类

1.单向链表
* 特点

链表是通过指针将自足零散的内存块串联起来，每个内存块称为链表的 **"结点"**，每个 **"结点"** 除了存储数据以外，还要记录链的下一个结点的地址。这个记录下个结点的指针叫做 **后继指针next**
第一个结点叫 **头结点**，头结点记录链表的基地址。
最后一个结点叫做 **尾结点**，尾结点指向空值 **Null**,表示链表的终点

* 时间复杂度分析

链表的插入和删除操作，只需要考虑相邻结点的指针改变，时间复杂度为O(1)；
链表的查询操作，需要根据指针一个结点一个结点的遍历，直到找到对应的结点，时间复杂度O(N)。

2.循环链表

循环链表是一种特殊的单链表。它跟单链表的区别在于尾结点，它的尾结点指针指向链表的头结点，像一个环一样首尾相连，所以叫循环链表。

3.双向链表

* 特点

单向链表只有一个方向，每个结点指向下一结点。而双向链表，支持两个方向，每个结点除了有后继指针next外，还有一个前驱指针prev，指向上一个结点.

双向链表需要额外的两个空间存储后继结点和前驱结点的地址，所以如果存储相同的数据，双向链表比单向链表需要更多的内存空间。

支持双向遍历，更加灵活。

* 时间复杂度分析

从结构上看，双向链表支持O(1)时间复杂度的情况下找到前驱结点，这个特点使得双向链表在某些情况下的插入、删除操作逗比单向链表更加高效、简单。

链表的删除操作

- 删除结点中"值等于某个给定值"结点
- 删除指定指针指向的结点


第一种删除，无论是单向链表还是双向链表，都需要从头结点开始一个个的遍历，直到找到给定值的结点，然后将其删除。

单纯删除操作的时间复杂度为O(1),但是遍历查找的时间复杂度为O(n),所以执行该删除操作的时间复杂度为O(n)，这个很容易理解。

第二种删除操作
这种情况下已经知道了要删除的结点，但是要删除该结点，需要知道其前驱结点，这时候双向链表优势就体现出来了。

单向链表是无法知道前驱结点的，要想知道，就得重新遍历一遍，时间复杂度为O(n)
双向链表结点中已经保存了前驱结点的指针，不需去重新遍历一遍了,时间复杂度为O(1)

同理，如果插入一个结点的话，双向链表时间复杂度为O(1),单向链表为O(n)。


* 用空间换时间涉及思想

时间软件开发中，双向链表比单向链表更耗内存，但是应用却比较广泛，这里有一个 **用空间换时间**的设计思想。

**在内存空间相对较充足的情况下，如果更加追求代码的执行速度，就可以选择空间复杂度相对较高，但是时间复杂度相对很低的算法或者数据结构。
相反，如果内存吃紧，例如代码在手机或者单片机，这时候就反过来用时间换空间的设计思路。**

* 应用场景：缓存

缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中广泛应用，例如CPU缓存、数据库缓存、浏览器缓存等。
缓存的大小有限，当缓存被用满时，哪些数据应该被清除，哪些应该被保留？需要缓存的淘汰策略来决定。
缓存淘汰策略
+ FIFO(First In First Out) 先进先出
+ LFU(Least Frequently Used) 最少使用
+ LRU(Least Recently Used) 最近最少使用

缓存是假上就是用空间换时间设计思想。如果把数据放到硬盘上，会比较节省内存，但是每次查找都需要询问一次硬盘，比较慢。
如果通过缓存技术，实现把数据加载到缓存，虽然耗费内存空间，但是可以大大提高数据查询的速度。

* 双向循环链表

双向链表 + 循环链表


* 链表 VS 数据

|时间复杂度 | 数组 | 链表|
|---------|------|----|
|插入和删除|O(n)|O(1)|
|随机访问|O(1)|O(n)|

数组和链表的对比不能只看时间复杂度

- 数组简单易用，存储上采用的是连续的空间，可以接触CPU缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中不连续存储，所以对CPU缓存不友好，没办法预读。
- 数组的缺点是大小固定，一经声明就占用连续的内存空间。如果声明的数组过大，系统没有足够的连续内存，那么就会导致"内存不足（Out of memory）"。如果申请的过小，会出现不够用的情况，
只能再申请更大的空间，把原数组拷贝进去，费时。链表本身没有大小的控制，天然支持动态扩容。

知识扩展：

**1.ArrayList的源代码实现？**
**2.LinkedList的源代码实现？**
**3.如何基于链表实现LRU缓存淘汰算法**

思路：
维护一个单向链表，越靠近链表尾部的结点是越早之前访问的，当一个新的数据被访问，从链表头遍历链表。
1.如果数据已经被链表缓存了，遍历到这个结点后，将其从原来的位置删除，再插入到链表头部。
2.如果不存在链表中，分两种情况：缓存未满，直接插入到头结点；缓存已满，则删除链表尾结点，新的数据结点插入头部。

可以看出该思路的时间复杂度为O(n)



